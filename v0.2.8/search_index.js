var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = AztecDiamonds","category":"page"},{"location":"#AztecDiamonds","page":"Home","title":"AztecDiamonds","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AztecDiamonds.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For an example notebook using this package, see here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here's a random diamond:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using AztecDiamonds\nshow(stdout, MIME(\"text/plain\"), diamond(10))","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [AztecDiamonds]","category":"page"},{"location":"#AztecDiamonds.Tiling","page":"Home","title":"AztecDiamonds.Tiling","text":"Tiling(N::Int[, x::OffsetMatrix{AztecDiamonds.Edge}]; sizehint::Int = N)\n\nRepresents an order N diamond-shaped tiling. If x is not provided, it is initialized with NONE representing an empty tiling. The sizehint keyword argument may be used to preallocate a larger matrix for x fitting a tiling of order sizehint to avoid reallocations when the tiling grows.\n\nThe indices of x represent the coordinates of the diamond-shaped tiling and run from 1-N to N (though x is allowed to be larger as long as it contains these indices). The edges it contains can either be UP, RIGHT, or NONE, where UP represents a vertical tile covering one more tile to the top, RIGHT represents a horizontal tile covering one more tile to the right. NONE means the edge is either already covered by another tile to the bottom or left or the tiling is not fully filled yet.\n\njulia> t = Tiling(1)\nOrder-1 Tiling{Matrix{AztecDiamonds.Edge}}\n\n\n\njulia> t[0, 0] = t[1, 0] = AztecDiamonds.RIGHT;\n\njulia> t\nOrder-1 Tiling{Matrix{AztecDiamonds.Edge}}\n🬇🬋🬋🬃\n🬇🬋🬋🬃\n\nSee diamond and ka_diamond for constructing a filled tiling.\n\n\n\n\n\n","category":"type"},{"location":"#AztecDiamonds.diamond-Tuple{Int64}","page":"Home","title":"AztecDiamonds.diamond","text":"diamond(N::Int) -> Tiling{Matrix{AztecDiamonds.Edge}}\n\nGenerates a uniformally random order N diamond tiling.\n\njulia> using Random; Random.seed!(1);\n\njulia> diamond(4)\nOrder-4 Tiling{Matrix{AztecDiamonds.Edge}}\n      🬇🬋🬋🬃\n    🬇🬋🬋🬃🬇🬋🬋🬃\n  🬦🬓🬦🬓🬦🬓🬦🬓🬇🬋🬋🬃\n🬦🬓🬉🬄🬉🬄🬉🬄🬉🬄🬇🬋🬋🬃🬦🬓\n🬉🬄🬦🬓🬦🬓🬇🬋🬋🬃🬦🬓🬦🬓🬉🬄\n  🬉🬄🬉🬄🬇🬋🬋🬃🬉🬄🬉🬄\n    🬇🬋🬋🬃🬇🬋🬋🬃\n      🬇🬋🬋🬃\n\nSee ka_diamond for a version that can take advantage of GPU acceleration. ka_diamond(N, Array) may also be faster for large N.\n\nRef Tiling\n\n\n\n\n\n","category":"method"},{"location":"#AztecDiamonds.ka_diamond-Tuple{Int64, Type{<:AbstractArray}}","page":"Home","title":"AztecDiamonds.ka_diamond","text":"ka_diamond(N::Int, ArrayT::Type{<:AbstractArray}) -> Tiling{ArrayT{Edge}}\n\nGenerate a uniformly random diamond tiling just like diamond, but using KernelAbstractions.jl to be able to take advantage of (GPU) parallelism. ArrayT can either be Array or any GPU array type.\n\nRef Tiling\n\n\n\n\n\n","category":"method"}]
}
